
WHITESPACE = _{ " " | "\t" | NEWLINE | ("#" ~ (!NEWLINE ~ ANY)*) | ("/*" ~ (!"*/" ~ ANY)* ~ "*/") }

CompUnit = { SOI ~ Item* ~ EOI }

Module = { "module" ~ Ident ~ "{" ~ Item* ~ "}" }

Item = { Use
       | Import
       | Def
       | Const
       | Type
       | Impl
       | Module
       }

Ident = { IdentNormal | IdentBuiltin | IdentUnderscore }

IdentNormal = @{ ASCII_ALPHA ~ (ASCII_ALPHANUMERIC | "_" )* }
IdentBuiltin = @{ "@" ~ ASCII_ALPHA ~ (ASCII_ALPHANUMERIC | "_" )* }
IdentUnderscore = @{ "_" ~ (ASCII_ALPHANUMERIC | "_" )* }

Import = { "import" ~ Ident }

Use = { "use" ~ UseTree }

UseTree = { Ident | UseTreeAll | UseTreeAlias | UseTreeMulti }

UseTreeAll = { Ident ~ "::" ~ "*" }
UseTreeAlias = { Ident ~ "as" ~ Ident }
UseTreeMulti = { Ident ~ "::" ~ "{" ~ UseTree ~ ("," ~ UseTree)* ~ "}" }
UseTreeSimple = { Ident ~ "::" ~ UseTree }

Const = { "const" ~ Ident ~ ":" ~ ApplyExpr ~ "=" ~ Expr }

Type = { "type" ~ TypeSpec? ~ Ident ~ FnLhs? ~ ("=" ~ TypeBody)? }
TypeBody = { Record | Interface | Expr | Constructors }
TypeSpec = { "builtin" }

Record = { "record" ~ "{" ~ (RecordField ~ ("," ~ RecordField)*)? ~ "}" }
RecordField = { Ident ~ ":" ~ Expr }

Constructors = { "|" ~ Constructor ~ ("|" ~ Constructor)* }
Constructor = { Ident ~ FnTyParamsImplicit? ~ FnTyParamsExplicit? ~ (":" ~ ApplyExpr)? }

Interface = { "interface" ~ "{" ~ Def* ~ "}" }

Impl = { "impl" ~ ApplyExpr ~ "{" ~ Def* ~ "}" }

Def = { "def" ~ DefSpec? ~ Ident ~ FnLhs ~ ("=>" ~ Expr)? }

DefSpec = { "builtin" }

Expr = {  Return | Break | Continue | FnExpr | Assign | OpExpr }

OpExpr = { PrefixOp* ~ ApplyExpr ~ PostfixOp* ~ (InfixOp ~ PrefixOp* ~ ApplyExpr ~ PostfixOp*)* }

FnExpr = { FnLhs ~ "=>" ~ Expr }
FnLhs = { FnParamsImplicit? ~ FnParamsExplicit? ~ (":" ~ ApplyExpr)? }
FnParamsImplicit = { "[" ~ (FnParam ~ ("," ~ FnParam)*)? ~ "]" }
FnParamsExplicit = { "(" ~ (FnParam ~ ("," ~ FnParam)*)? ~ ")" }
FnParam = { Ident ~ (":" ~ ApplyExpr)? }

FnTy = { FnTyParamsImplicit? ~ FnTyParamsExplicit? ~ "->" ~ ApplyExpr }
FnTyParamsImplicit = { "[" ~ (FnTyParam ~ ("," ~ FnTyParam)*)? ~ "]" }
FnTyParamsExplicit = { "(" ~ (FnTyParam ~ ("," ~ FnTyParam)*)? ~ ")" }
FnTyParam = { (Ident ~ ":")? ~ ApplyExpr }

ApplyExpr = { QualifiedPath ~ FnArgs* }
QualifiedPath = { (PrimaryExpr ~ FnArgs* ~ "::")* ~ PrimaryExpr }
FnArgs = { FnArgsExplicit | FnArgsImplicit }
FnArgsExplicit = { "(" ~ (FnArg ~ ("," ~ FnArg)*)? ~ ")" }
FnArgsImplicit = { "[" ~ (FnArg ~ ("," ~ FnArg)*)? ~ "]" }
FnArg = { (Ident ~ "=")? ~ Expr }

Tuple = { "(" ~ Expr ~ ("," ~ Expr)+ ~ ")" }

PrimaryExpr = { Universe
              | Unit
              | Literal
              | ExprWithBlock
              | Ident
              | RangeFull
              | FnTy 
              | Tuple
              | "(" ~ Expr ~ ")"
              }

ExprWithBlock = { Loop 
                | While 
                | For
                | If 
                | IfLet
                | Match
                | Block
                }

Assign = { OpExpr ~ "=" ~ Expr }

Loop = { Label? ~ "loop" ~ Block }

Continue = { "continue" ~ Label? }

While = { Label? ~ "while" ~ Expr ~ Block }

For = { Label? ~ "for" ~ Pattern ~ "in" ~ Expr ~ Block }

If = { "if" ~ Expr ~ Block ~ ("else" ~ ExprWithBlock)?}

IfLet = { "if" ~ "let" ~ Pattern ~ "=" ~ Expr ~ Block ~ ("else" ~ ExprWithBlock)? }

RangeFull = { ".." }

Block = { BlockSpec? ~ Label? ~ "{" ~ Stmt* ~ "}" }
BlockSpec = { "comptime" }
Label = ${ "'" ~ Ident }

Stmt = { Let | Item | Expr }

Let = { "let" ~ PatternWithoutRange ~ (":" ~ ApplyExpr)? ~ ("=" ~ Expr)? }

Match = { "match" ~ Expr ~ "{" ~ MatchArm ~ ("," ~ MatchArm)* ~ "}" }
MatchArm = { Pattern ~ "=>" ~ Expr }

Pattern = { "|"? ~ PrimaryPattern ~ ("|" ~ PrimaryPattern)* }

PrimaryPattern = { RangePattern | PatternWithoutRange }

PatternWithoutRange = { WildcardPattern
                      | RestPattern
                      | LiteralPattern
                      | RecordPattern 
                      | ConstructorPattern
                      | QualifiedPattern
                      | IdentPattern
                      | TuplePattern
                      | "(" ~ Pattern ~ ")"
                      }

LiteralPattern = { Literal }

IdentPattern = { IdentPatternSpec? ~ Ident }
IdentPatternSpec = { "comptime" 
                   | "mut" 
                   | "ref" 
                   | "ref" ~ "mut" 
                   }

WildcardPattern = { "_" }

RestPattern = { ".." }

RecordPattern = { QualifiedPath ~ "{" ~ (RecordPatternElem ~ ("," ~ RecordPatternElem)*)? ~ "}" }
RecordPatternElem = { RecordPatternField | RestPattern }
RecordPatternField = { Ident ~ ":" ~ Pattern }

RangePattern = { RangePatternInclusive 
               | RangePatternExclusive 
               | RangePatternFrom 
               | RangePatternTo 
               | RangePatternToInclusive
               }
RangePatternBound = { Literal | QualifiedPath }
RangePatternInclusive = { RangePatternBound ~ "..=" ~ RangePatternBound }
RangePatternExclusive = { RangePatternBound ~ ".." ~ RangePatternBound }
RangePatternFrom = { RangePatternBound ~ ".." }
RangePatternTo = { ".." ~ RangePatternBound }
RangePatternToInclusive = { "..=" ~ RangePatternBound }

ConstructorPattern = { QualifiedPath ~ ConstructorPatternArgsExplicit
                     | QualifiedPath ~ ConstructorPatternArgsImplicit 
                     | QualifiedPath ~ ConstructorPatternArgsImplicit ~ ConstructorPatternArgsExplicit 
                     }
ConstructorPatternArgsImplicit = { "[" ~ (ConstructorPatternArg ~ ("," ~ ConstructorPatternArg)*)? ~ "]" }
ConstructorPatternArgsExplicit = { "(" ~ (ConstructorPatternArg ~ ("," ~ ConstructorPatternArg)*)? ~ ")" }
ConstructorPatternArg = { (Ident ~ "=")? ~ Pattern }

TuplePattern = { "(" ~ Pattern ~ ("," ~ Pattern)+ ~ ")" } 

QualifiedPattern = { QualifiedPath }

Return = { "return" ~ Expr? }

Break = { "break" ~ Label? ~ Expr? }

Universe = @{ "Type" }

Unit = @{ "Unit" }

Literal = { Floating | HexInteger | OctInteger | BinInteger | DecInteger }

LiteralSuffix = { "u8" 
                | "u16"
                | "u32"
                | "u64"
                | "i8"
                | "i16"
                | "i32"
                | "i64"
                | "f32"
                | "f64"
                | "usize"
                | "isize"
                }

HexPrefix = { "0x" | "0X" }
OctPrefix = { "0o" | "0O" }
BinPrefix = { "0b" | "0B" }

DecBody = { (ASCII_DIGIT | "_")+ }
HexBody = { (ASCII_HEX_DIGIT | "_")+ }
OctBody = { (ASCII_OCT_DIGIT | "_")+ }
BinBody = { (ASCII_BIN_DIGIT | "_")+ }

DecInteger = ${ DecBody ~ LiteralSuffix? }
HexInteger = ${ HexPrefix ~ HexBody ~ LiteralSuffix? }
OctInteger = ${ OctPrefix ~ OctBody ~ LiteralSuffix? }
BinInteger = ${ BinPrefix ~ BinBody ~ LiteralSuffix? }

Exponent = @{ ("e" | "E") ~ ("+" | "-")? ~ DecBody }
DecimalPart = @{ "." ~ DecBody }
Floating = ${ DecBody ~ DecimalPart ~ Exponent ~ LiteralSuffix? 
            | DecBody ~ Exponent ~ LiteralSuffix?
            | DecBody ~ DecimalPart ~ LiteralSuffix? 
            }

Add = { "+" }
Sub = { "-" }
Mul = { "*" }
Div = { "/" }
Rem = { "%" }
Dot = { "." }
Shl = { "<<" }
Shr = { ">>" }

Range = { ".." }
RangeFrom = { ".." }
RangeTo = { ".." }
RangeInclusive = { "..=" }
RangeToInclusive  = { "..=" }

LogicalAnd = { "&&" }
LogicalOr  = { "||" }

BitwiseAnd = { "&" }
BitwiseOr  = { "|" }
BitwiseXor = { "^" }

Eq = { "==" }
Ne = { "!=" }
Lt = { "<" }
Le = { "<=" }
Gt = { ">" }
Ge = { ">=" }

Pos = { "+" }
Neg = { "-" }
Ref = { "&" }
Deref = { "*" }
LogicalNot = { "!" }
BitwiseNot = { "~" }

InfixOp = _{ Add 
           | Sub 
           | Mul 
           | Div 
           | Rem 
           | Dot // TODO: Make `Dot` a `QualifiedPath`-like expression.
           | Shl
           | Shr
           | LogicalAnd 
           | LogicalOr 
           | BitwiseAnd 
           | BitwiseOr 
           | BitwiseXor 
           | Eq 
           | Ne 
           | Lt 
           | Le 
           | Gt 
           | Ge
           | Range
           | RangeInclusive
           }

PrefixOp = _{ Pos 
            | Neg 
            | Ref 
            | Deref 
            | LogicalNot 
            | BitwiseNot 
            | RangeTo
            | RangeToInclusive
            }

PostfixOp = _{ RangeFrom }